/* eslint-disable jsx-a11y/mouse-events-have-key-events */

import React, { useCallback, useEffect, useRef, useState } from 'react';
import PropTypes from 'prop-types';

import Teleporter from './Teleporter';

import './Tooltip.less';

const Tooltip = ({ body, children, className = '', onShow }) => {
  const containerRef = useRef();
  const tooltipRef = useRef();
  const [isComputing, setIsComputing] = useState(true);
  const [isShown, setIsShown] = useState(false);
  const [offsets, setOffsets] = useState({
    arrow: 0,
    left: 0,
    top: 0,
  });

  const handleHide = useCallback(() => {
    setIsShown(false);
  }, []);

  const handleOutsideClick = useCallback(event => {
    const clickedInContainer = containerRef.current?.contains(event.target);
    const clickedInTooltip = tooltipRef.current?.contains(event.target);

    if (!clickedInContainer && !clickedInTooltip) {
      handleHide();
    }
  }, [handleHide]);

  const handleResize = useCallback(() => {
    setIsShown(false);
  }, []);

  const handleShow = useCallback(() => {
    if (!isShown) {
      setIsShown(true);
      onShow?.();
    }
  }, [isShown, onShow]);

  const reset = useCallback(() => {
    setIsComputing(true);
    setOffsets({
      arrow: 0,
      left: 0,
      top: 0,
    });
  }, []);

  useEffect(() => {
    if (isShown) {
      document.addEventListener('mousedown', handleOutsideClick);
    }

    return () => {
      document.removeEventListener('mousedown', handleOutsideClick);
    };
  }, [handleOutsideClick, isShown]);

  useEffect(() => {
    reset();

    if (isShown) {
      window.addEventListener('resize', handleResize);

      setTimeout(() => {
        const targetBox = containerRef.current.firstElementChild.getBoundingClientRect();
        const tooltipBox = tooltipRef.current.getBoundingClientRect();

        const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
        const desiredLeft = targetBox.left + (targetBox.width / 2) - (tooltipBox.width / 2);

        const minLeft = Math.max(0, desiredLeft);
        const maxLeft = window.innerWidth - tooltipBox.width - scrollbarWidth;

        const left = Math.min(minLeft, maxLeft);
        const top = targetBox.bottom + window.scrollY;

        const overflowLeft = desiredLeft - minLeft;
        const overflowRight = desiredLeft - left;
        const arrow = overflowLeft || overflowRight;

        setOffsets({
          arrow,
          left,
          top,
        });
        setIsComputing(false);
      }, 0);

      return () => window.removeEventListener('resize', handleResize);
    }

    return undefined;
  }, [handleResize, isShown, reset]);

  if (!children) {
    return null;
  }

  return (
    <div
      className="exp-tooltip-container"
      onMouseDown={handleShow}
      onMouseLeave={handleHide}
      onMouseOver={handleShow}
      ref={containerRef}
    >
      {children}
      {isShown && (
        <Teleporter target={document.body}>
          <div
            className={`exp-tooltip ${className}`}
            data-computing={isComputing}
            ref={tooltipRef}
            style={{
              '--offset-arrow': offsets.arrow,
              '--offset-left': offsets.left,
              '--offset-top': offsets.top,
            }}
          >
            {body}
          </div>
        </Teleporter>
      )}
    </div>
  );
};

Tooltip.propTypes = {
  body: PropTypes.node.isRequired,
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
  onShow: PropTypes.func,
};

export default Tooltip;
