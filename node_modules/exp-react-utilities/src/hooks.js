import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useInView } from 'react-intersection-observer';
import { debounce } from 'lodash';

import { MEDIA_QUERIES } from './responsiveUtils';

/**
 * Returns a debounced callback function that is durable across renders
 *
 * TODO: this is probably wonky a bit w/ the hook dependencies
 *
 * @param callback The function to invoke after the timeout
 * @param timeout The timeout in ms
 * @returns Debounced function
 */
export const useDebounce = (callback, timeout = 0) => {
  const ref = useRef(debounce(callback, timeout));
  return ref.current;
};

/**
 * Pushes a URL onto the history stack and manages it being replaced/popped off
 *
 * @param callback The function to call when the item is popped off the history stack
 * @param next The next state URL to push
 * @param previous The previous URL to go back to. Defaults to the current URL.
 * @returns Function to call to force the history item to be popped off
 */
export const useHistoryPush = (callback, next, previous = window.location.href) => {
  const closed = useRef(false);
  const listener = useCallback((e) => {
    if (!closed.current) { // Only execute the listener once
      closed.current = true;

      e?.preventDefault?.();
      if (e?.type !== 'popstate') {
        // Replace the history entry unless the user goes back in the browser
        window.history?.replaceState?.(null, null, previous);
      }

      callback(e);
    }
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  useEffect(() => {
    // Add the next state onto the history stack
    window.history?.pushState?.(null, null, next);

    window.addEventListener('popstate', listener);
    return () => {
      listener(new Event('ev-custom-popstate')); // Ensure the listener is invoked to clean up the history state
      window.removeEventListener('popstate', listener);
    };
  }, [listener, next]);

  return listener;
};

/**
 * Provides functionality to track & report when an element is viewed in the browser
 *
 * @param onView Callback function when the element is first scrolled into view
 * @param skip Flag if the observer should be skipped
 * @param threshold 0-1 range indicating the % of the element needed in view to be intersected
 * @returns Response from useInView hook
 */
export const useViewed = ({
  onView = () => {},
  skip = false,
  threshold = 0.95,
} = {}) => {
  const intersected = useRef(false);
  return useInView({
    onChange: (inView, entry) => {
      if (inView && !intersected.current) {
        intersected.current = true;
        onView?.(entry);
      }
    },
    skip: skip || !onView || intersected.current,
    threshold,
  });
};

/**
 * Tracks and maintains a state variable for whether or not a media query matches
 *
 * @param mq Media Query
 * @return A boolean indicating that the media query matches or not
 */
export const useMediaQuery = (mq) => {
  // Create a state variable to track whether the media query matches
  const [matches, setMatches] = useState(mq.matches);

  // Bind a listener to the media query change event to update the state when it changes
  useEffect(() => {
    const listener = () => setMatches(mq.matches);
    mq.addEventListener('change', listener);
    return () => mq.removeEventListener('change', listener);
  }, [mq]);

  return matches;
};

export const useIsMediaXS = () => useMediaQuery(MEDIA_QUERIES.xs);
export const useIsMediaSM = () => useMediaQuery(MEDIA_QUERIES.sm);
export const useIsMediaMD = () => useMediaQuery(MEDIA_QUERIES.md);
export const useIsMediaLG = () => useMediaQuery(MEDIA_QUERIES.lg);
export const useIsMediaXL = () => useMediaQuery(MEDIA_QUERIES.xl);

/**
 * Custom hook to detect if an element is being shown on screen.
 *
 * @param ref A reference to an element to observe.
 * @return A boolean indicating if the referenced element is visible on the screen.
 */
export const useOnScreen = (ref) => {
  const [isIntersecting, setIntersecting] = useState(false);

  const observer = useMemo(
    () => new IntersectionObserver(([entry]) => {
      if (entry.isIntersecting) {
        setIntersecting(entry.isIntersecting);
      }
    }), [],
  );

  useEffect(() => {
    if (ref.current) {
      observer.observe(ref.current);
    }
    return () => {
      observer.disconnect();
    };
  }, [observer, ref]);

  return isIntersecting;
};

/**
 * Custom hook to store the value of a variable prior to the latest rendered state
 *
 * @param value The current value to track
 * @return The previous value
 */
export const usePrevious = (value) => {
  const ref = useRef();
  useEffect(() => {
    // Update the current value only when it isn't identical to the existing one (re-render)
    if (!ref.current || ref.current !== value) {
      ref.current = value;
    }
  });

  return ref.current;
};
